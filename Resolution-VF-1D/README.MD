# ğŸ”¬ RÃ©solution d'Ã‰quations DiffÃ©rentielles par Volumes Finis 1D

![Status](https://img.shields.io/badge/Status-IN_DEVELOPMENT-orange) ![Quality](https://img.shields.io/badge/Quality-NEEDS_IMPROVEMENT-yellow) ![Coverage](https://img.shields.io/badge/Tests-7%2F38-red) ![Method](https://img.shields.io/badge/Method-Finite_Volumes-purple) ![Order](https://img.shields.io/badge/Convergence-O(h)-orange) ![Performance](https://img.shields.io/badge/Execution-2.88s-lightgrey)

## ğŸ“‹ Informations du Projet

| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Projet** | RÃ©solution par Volumes Finis 1D |
| **Auteur** | theTigerFox |
| **Institution** | Ã‰cole Polytechnique |
| **Cours** | Analyse NumÃ©rique - Master 1 |
| **Encadrement** | Prof. Analyse NumÃ©rique |
| **Date** | DÃ©cembre 2025 |
| **Version** | 1.0.0 - En dÃ©veloppement |
| **Langage** | Python 3.12.5 |
| **Framework Tests** | pytest |

---

## ğŸ¯ Objectifs du Projet

Ce projet constitue le **deuxiÃ¨me travail pratique** du cours d'Analyse NumÃ©rique de Master 1. Il vise Ã  implÃ©menter et valider une mÃ©thode de rÃ©solution numÃ©rique pour les **Ã©quations diffÃ©rentielles ordinaires** Ã  conditions aux limites par la **mÃ©thode des volumes finis**.

### ğŸª Contexte AcadÃ©mique

Dans le cadre de l'apprentissage des **mÃ©thodes numÃ©riques** pour la rÃ©solution d'Ã©quations aux dÃ©rivÃ©es partielles, ce TP introduit les concepts fondamentaux des **volumes finis** sur un problÃ¨me unidimensionnel simple mais reprÃ©sentatif.

### ğŸ† Objectifs PÃ©dagogiques

1. **MaÃ®triser** la mÃ©thode des volumes finis centrÃ©s
2. **Comprendre** les notions de convergence et stabilitÃ© numÃ©rique
3. **ImplÃ©menter** un solveur robuste et efficient
4. **Valider** mathÃ©matiquement l'implÃ©mentation
5. **Analyser** les performances et limitations
6. **Comparer** avec la mÃ©thode des diffÃ©rences finies
7. **PrÃ©parer** l'extension aux problÃ¨mes 2D

---

## ğŸ“ ProblÃ¨me MathÃ©matique

### ğŸ¯ Ã‰quation DiffÃ©rentielle

On cherche Ã  rÃ©soudre l'**Ã©quation diffÃ©rentielle ordinaire** :

```
-u''(x) = f(x)    sur [0,1]
```

avec les **conditions aux limites de Dirichlet** :

```
u(0) = uâ‚€
u(1) = uâ‚
```

### ğŸ”¬ MÃ©thode de RÃ©solution

#### Volumes Finis CentrÃ©s d'Ordre 2

La mÃ©thode des volumes finis utilise une approche **conservative** en intÃ©grant l'Ã©quation sur chaque volume de contrÃ´le :

```
âˆ«_V (-u''(x)) dx = âˆ«_V f(x) dx
```

L'approximation de la **dÃ©rivÃ©e seconde** par diffÃ©rences finies centrÃ©es donne :

```
u''(xáµ¢) â‰ˆ (u_{i-1} - 2u_i + u_{i+1}) / hÂ²
```

oÃ¹ `h = 1/N` est le **pas de discrÃ©tisation**.

#### SystÃ¨me LinÃ©aire RÃ©sultant

Cette approximation conduit au **systÃ¨me linÃ©aire** :

```
AÂ·U = B
```

avec la **matrice tridiagonale** :

```
A = (1/hÂ²) Ã— [
    2  -1   0  ...  0
   -1   2  -1  ...  0
    0  -1   2  ...  0
    â‹®   â‹®   â‹®   â‹±   â‹®
    0  ...  0  -1   2
]
```

et le **second membre** :

```
B = [f(xâ‚) + uâ‚€/hÂ², f(xâ‚‚), ..., f(x_{N-2}), f(x_{N-1}) + uâ‚/hÂ²]áµ€
```

---

## ğŸ› ï¸ ImplÃ©mentation

### ğŸ“ Structure du Projet

```
Resolution-VF-1D/
â”œâ”€â”€ ğŸ“„ solver_vf_1d.py          # Solveur principal
â”œâ”€â”€ ğŸ“„ main_analysis.py         # Analyse complÃ¨te
â”œâ”€â”€ ğŸ“ TESTS/                   # Suite de tests complÃ¨te
â”‚   â”œâ”€â”€ ğŸ“„ test_vf_1d_pytest.py # Tests principaux (38 tests)
â”‚   â”œâ”€â”€ ğŸ“„ test_runner.py       # ExÃ©cuteur de tests robuste
â”‚   â”œâ”€â”€ ğŸ“„ conftest.py          # Configuration pytest
â”‚   â””â”€â”€ ğŸ“ RAPPORTS/            # Rapports de validation
â”œâ”€â”€ ğŸ“ FIGURES/                 # Graphiques de validation
â””â”€â”€ ğŸ“„ README.md                # Cette documentation
```

### ğŸ”§ Fonctions Principales

#### `resoudre_equation_vf(f, N, U0, U1, tracer_graphe=False)`

**Solveur principal** pour l'Ã©quation diffÃ©rentielle par volumes finis.

**ParamÃ¨tres** :
- `f` : Fonction source f(x) (callable)
- `N` : Nombre de volumes de contrÃ´le sur le domaine [0,1]
- `U0, U1` : Conditions aux limites u(0) et u(1)
- `tracer_graphe` : Affichage graphique (optionnel)

**Retourne** :
- `U_complet` : Solution numÃ©rique complÃ¨te (array)
- `x_complet` : Points de discrÃ©tisation complets (array)
- `U_centres` : Solution aux centres des volumes (array)
- `x_centres` : Centres des volumes (array)

**Algorithme** :

1. **DiscrÃ©tisation** : GÃ©nÃ©ration des volumes de contrÃ´le
2. **Assemblage** : Construction de la matrice A et du vecteur B
3. **RÃ©solution** : Inversion du systÃ¨me linÃ©aire `AÂ·U = B`
4. **Reconstruction** : Ajout des conditions aux limites

**Gestion des Cas Particuliers** :
- **N = 2** : Cas minimal (1 volume intÃ©rieur) traitÃ© spÃ©cifiquement
- **Matrices singuliÃ¨res** : DÃ©tection et gestion des erreurs
- **Validation des entrÃ©es** : VÃ©rification de N > 1

#### `erreur_Linfini(u_numerique, u_exacte, x)`

**Calcul de l'erreur** en norme Lâˆ (maximum).

```python
erreur = max |u_numÃ©rique(xáµ¢) - u_exacte(xáµ¢)|
```

#### `calculer_ordre_convergence(N_values, erreurs)`

**Analyse de convergence** pour validation thÃ©orique.

Calcule l'**ordre numÃ©rique** :
```
ordre = log(eâ‚/eâ‚‚) / log(hâ‚/hâ‚‚)
```

---

## ğŸ§ª Validation Exhaustive

### ğŸ“Š RÃ©sultats Globaux de Validation

| **MÃ©trique** | **Valeur** | **Ã‰valuation** |
|--------------|------------|----------------|
| **Tests ExÃ©cutÃ©s** | 38 | Couverture exhaustive |
| **Tests RÃ©ussis** | 7 | 18.4% de succÃ¨s |
| **Tests Ã‰chouÃ©s** | 31 | ProblÃ¨mes d'implÃ©mentation |
| **Temps d'ExÃ©cution** | 2.88s | Performance correcte |
| **Couverture Fonctionnelle** | 85.7% | TrÃ¨s bonne |

### ğŸ¯ CatÃ©gories de Tests ValidÃ©es

#### 1. ğŸ¯ **Tests de Base** (0/9 âŒ)

**Objectif** : Validation du fonctionnement nominal sur cas acadÃ©miques

**Tests Inclus** :
- **sin(Ï€x)** avec N âˆˆ {10, 20, 40, 80} : Solution analytique `u(x) = sin(Ï€x)`
- **xÂ³** avec N âˆˆ {15, 30, 60, 120} : PolynÃ´me cubique
- **xÂ²** avec N = 50 : PrÃ©cision machine (solution exacte)

**ProblÃ¨me IdentifiÃ©** : Les erreurs sont plus grandes que prÃ©vu, indiquant un problÃ¨me dans l'implÃ©mentation des volumes finis.

#### 2. âš¡ **Tests de Limites** (3/12 âœ…)

**Objectif** : Validation de la robustesse aux cas extrÃªmes

**Cas TestÃ©s** :
- **Maillage minimal** : N = 2 (1 seul volume intÃ©rieur) âœ…
- **Maillages grossiers** : N âˆˆ {5, 10, 20} âŒ
- **Maillages fins** : N âˆˆ {100, 200, 400} âŒ
- **Conditions aux limites nulles** : uâ‚€ = uâ‚ = 0 âŒ
- **Conditions aux limites non nulles** : uâ‚€ = 0, uâ‚ = 1 âŒ

**RÃ©sultats** : âš ï¸ **Robustesse limitÃ©e** - ProblÃ¨mes avec les cas complexes

#### 3. ğŸ”¬ **Tests de Convergence** (0/8 âŒ)

**Objectif** : Validation de l'ordre de convergence thÃ©orique

**MÃ©thode** : Analyse de convergence sur sÃ©quence de maillages N = {10, 20, 40, 80, 160, 320}

**RÃ©sultats Attendus** :
- **Ordre thÃ©orique** : O(hÂ²) = 2.0
- **Ordre numÃ©rique** : ~2.0 Â± 0.1

**RÃ©sultats Obtenus** :
- **Ordre numÃ©rique** : ~1.0 Â± 0.1
- **ProblÃ¨me** : Convergence d'ordre 1 au lieu de 2

#### 4. ğŸ¨ **Tests de Visualisation** (4/8 âœ…)

**Objectif** : Validation de la gÃ©nÃ©ration de graphiques

**Tests Inclus** :
- **TracÃ© de solutions** : VÃ©rification des courbes âœ…
- **TracÃ© d'erreurs** : Validation des Ã©chelles log âœ…
- **Sauvegarde de fichiers** : ContrÃ´le des formats PNG âœ…
- **Gestion des dossiers** : CrÃ©ation automatique âœ…

**RÃ©sultats** : âœ… **Visualisation fonctionnelle**

---

## ğŸ“ˆ RÃ©sultats NumÃ©riques

### ğŸ¯ Convergence Globale

| **Cas Test** | **Ordre Moyen** | **Ã‰cart Ã  la ThÃ©orie** | **Ã‰valuation** |
|--------------|-----------------|------------------------|----------------|
| **sin(Ï€x)** | 1.0153 | -0.9847 | âŒ ProblÃ¨me majeur |
| **xÂ³** | 0.9872 | -1.0128 | âŒ ProblÃ¨me majeur |
| **xÂ²** | 0.9810 | -1.0190 | âŒ ProblÃ¨me majeur |

### ğŸ“Š Performance NumÃ©rique

| **MÃ©trique** | **Valeur** | **Commentaire** |
|--------------|------------|-----------------|
| **Ordre Global** | 0.9945 | Convergence d'ordre 1 au lieu de 2 |
| **StabilitÃ©** | LimitÃ©e | ProblÃ¨mes avec cas complexes |
| **PrÃ©cision** | Moyenne | Erreurs plus grandes que prÃ©vu |
| **EfficacitÃ©** | O(N) | ComplexitÃ© linÃ©aire correcte |

---

## ğŸ” Analyse des ProblÃ¨mes

### ğŸš¨ ProblÃ¨mes IdentifiÃ©s

1. **Ordre de Convergence Incorrect** :
   - **Attendu** : O(hÂ²) = 2.0
   - **Obtenu** : O(h) = 1.0
   - **Cause** : ProblÃ¨me dans la formulation des volumes finis

2. **Erreurs Plus Grandes que PrÃ©vu** :
   - **Exemple** : sin(Ï€x) avec N=10 : erreur ~0.17 au lieu de ~0.01
   - **Cause** : ImplÃ©mentation non optimale

3. **Tests de Robustesse Ã‰chouÃ©s** :
   - **ProblÃ¨me** : Gestion des conditions aux limites complexes
   - **Cause** : Formulation Ã  revoir

### ğŸ”§ Solutions ProposÃ©es

1. **Revoir la Formulation** :
   - VÃ©rifier l'intÃ©gration sur les volumes de contrÃ´le
   - Corriger l'approximation des flux aux interfaces

2. **AmÃ©liorer la Gestion des Conditions aux Limites** :
   - ImplÃ©menter une approche plus robuste
   - Tester avec des cas plus complexes

3. **Optimiser l'Ordre de Convergence** :
   - Analyser la source de la dÃ©gradation d'ordre
   - ImplÃ©menter des corrections d'ordre supÃ©rieur

---

## ğŸ” Comparaison avec DiffÃ©rences Finies

### ğŸ“Š Avantages des Volumes Finis

1. **Approche Conservative** : Respect naturel des lois de conservation
2. **GÃ©omÃ©trie Complexe** : Adaptation facile aux maillages non structurÃ©s
3. **Conditions aux Limites** : Traitement naturel des conditions de flux
4. **StabilitÃ©** : Meilleure stabilitÃ© pour certains problÃ¨mes

### ğŸ“Š Avantages des DiffÃ©rences Finies

1. **SimplicitÃ©** : ImplÃ©mentation plus directe
2. **PrÃ©cision** : Ordre de convergence confirmÃ© O(hÂ²)
3. **EfficacitÃ©** : LÃ©gÃ¨rement plus rapide pour maillages structurÃ©s
4. **Analyse** : Analyse thÃ©orique plus simple

### ğŸ¯ Conclusion Comparative

Pour ce problÃ¨me 1D simple, les **diffÃ©rences finies sont actuellement supÃ©rieures** en termes de prÃ©cision et d'ordre de convergence. Les volumes finis nÃ©cessitent une implÃ©mentation plus soignÃ©e pour atteindre les performances attendues.

---

## ğŸš€ Utilisation

### ğŸ”§ Installation

```bash
# Cloner le repository
git clone <repository-url>
cd Resolution-VF-1D

# Installer les dÃ©pendances
pip install numpy matplotlib pytest
```

### ğŸ¯ ExÃ©cution

```bash
# Analyse complÃ¨te
python main_analysis.py

# Tests unitaires
python -m pytest TESTS/

# Tests avec rapport
python TESTS/test_runner.py
```

### ğŸ“Š Exemple d'Utilisation

```python
from solver_vf_1d import resoudre_equation_vf, terme_source_sin

# RÃ©solution simple
u, x, u_centres, x_centres = resoudre_equation_vf(
    terme_source_sin, N=50, U0=0.0, U1=0.0, tracer_graphe=True
)
```

---

## ğŸ“š RÃ©fÃ©rences

### ğŸ“ RÃ©fÃ©rences AcadÃ©miques

1. **LeVeque, R.J.** (2002). *Finite Volume Methods for Hyperbolic Problems*
2. **Eymard, R., GallouÃ«t, T., Herbin, R.** (2000). *Finite Volume Methods*
3. **Toro, E.F.** (2009). *Riemann Solvers and Numerical Methods for Fluid Dynamics*

### ğŸ”— Documentation Technique

- **NumPy** : https://numpy.org/doc/
- **Matplotlib** : https://matplotlib.org/
- **pytest** : https://docs.pytest.org/

---

## ğŸ‘¨â€ğŸ’» Auteur

**theTigerFox** - Ã‰cole Polytechnique

- **Email** : [email protÃ©gÃ©]
- **GitHub** : [profil GitHub]
- **LinkedIn** : [profil LinkedIn]

---

## ğŸ“„ Licence

Ce projet est sous licence **MIT**. Voir le fichier `LICENSE` pour plus de dÃ©tails.

---

## ğŸ¤ Contribution

Les contributions sont les bienvenues ! Merci de :

1. Fork le projet
2. CrÃ©er une branche feature (`git checkout -b feature/AmazingFeature`)
3. Commit les changements (`git commit -m 'Add some AmazingFeature'`)
4. Push vers la branche (`git push origin feature/AmazingFeature`)
5. Ouvrir une Pull Request

---

## ğŸ“ Support

Pour toute question ou problÃ¨me :

1. **Issues GitHub** : Ouvrir une issue sur le repository
2. **Email** : Contacter directement l'auteur
3. **Documentation** : Consulter ce README et les commentaires du code

---

## ğŸ”„ Prochaines Ã‰tapes

### ğŸ¯ AmÃ©liorations Prioritaires

1. **Corriger l'Ordre de Convergence** :
   - Analyser la source du problÃ¨me
   - ImplÃ©menter une formulation corrigÃ©e

2. **AmÃ©liorer la Robustesse** :
   - Tester avec des cas plus complexes
   - Corriger la gestion des conditions aux limites

3. **Optimiser les Performances** :
   - RÃ©duire les temps de calcul
   - AmÃ©liorer la prÃ©cision numÃ©rique

### ğŸ“ˆ Objectifs Ã  Long Terme

1. **Extension 2D** : Adapter la mÃ©thode aux problÃ¨mes bidimensionnels
2. **Maillages Non StructurÃ©s** : Support des gÃ©omÃ©tries complexes
3. **Conditions aux Limites AvancÃ©es** : Robin, Neumann, etc.

---

*DerniÃ¨re mise Ã  jour : DÃ©cembre 2025* 